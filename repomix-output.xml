This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  .worker-tracking/
    bde36376/
      hivemind_find.marker
      hivemind_store.marker
      swarmmail_init.marker
  settings.local.json
.env.example
.gitignore
bot.py
commands.py
config.py
database.py
events.py
PRD.md
README.md
requirements.txt
utils.py
video_ranking.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "mcp__plugin_swarm_swarm-tools__hivemind_store",
      "mcp__plugin_swarm_swarm-tools__swarm_complete",
      "mcp__plugin_swarm_swarm-tools__swarmmail_send",
      "Bash(git pull:*)",
      "Bash(git merge:*)",
      "Bash(git stash:*)"
    ]
  }
}
</file>

<file path=".claude/.worker-tracking/bde36376/hivemind_find.marker">
2026-02-08T06:00:17.449Z
</file>

<file path=".claude/.worker-tracking/bde36376/hivemind_store.marker">
2026-02-08T06:01:09.151Z
</file>

<file path=".claude/.worker-tracking/bde36376/swarmmail_init.marker">
2026-02-08T06:00:58.535Z
</file>

<file path=".env.example">
DISCORD_TOKEN=seu_token_aqui
COMMAND_PREFIX=!
</file>

<file path=".gitignore">
# Environment variables
.env

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
env/
ENV/
.venv/

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
</file>

<file path="bot.py">
#!/usr/bin/env python3
"""
bot.py - Ponto de entrada principal do Bot Discord de Ranking de Atividade.

Este m√≥dulo configura e inicializa o bot Discord, registrando eventos e comandos
conforme especificado na se√ß√£o 4.3 do PRD.
"""

import logging
import sys
from typing import NoReturn

import discord
from discord.ext import commands

# Importar configura√ß√µes dos m√≥dulos
from config import DISCORD_TOKEN, COMMAND_PREFIX, get_intents, setup_logger

# Configura√ß√£o de logging
logger = setup_logger(__name__)


def create_bot() -> commands.Bot:
    """
    Cria e configura a inst√¢ncia do bot Discord.

    Configura o bot com:
    - Command prefix do ambiente
    - Intents configurados
    - Event handlers registrados
    - Command handlers registrados
    - Tratamento de erros

    Returns:
        commands.Bot: Inst√¢ncia do bot configurada
    """
    # Criar bot com intents e prefix do config
    bot = commands.Bot(
        command_prefix=COMMAND_PREFIX,
        intents=get_intents(),
        help_command=None  # Desabilita comando de help padr√£o
    )

    @bot.event
    async def on_ready() -> None:
        """
        Evento chamado quando o bot est√° conectado e pronto.

        Loga informa√ß√µes de conex√£o e inicializa sistemas.
        """
        logger.info(f'Bot conectado como {bot.user.name}#{bot.user.discriminator}')
        logger.info(f'ID do bot: {bot.user.id}')
        logger.info(f'Conectado a {len(bot.guilds)} servidores')

        # Configurar status do bot
        await bot.change_presence(
            activity=discord.Activity(
                type=discord.ActivityType.watching,
                name='c√¢meras ligadas'
            )
        )

    @bot.event
    async def on_voice_state_update(
        member: discord.Member,
        before: discord.VoiceState,
        after: discord.VoiceState
    ) -> None:
        """
        Evento chamado quando h√° mudan√ßa no estado de voz de um membro.

        Detecta quando usu√°rios ligam/desligam c√¢mera e atualiza o ranking.
        Conforme RF01 do PRD.

        Args:
            member: Membro do Discord que teve mudan√ßa de estado
            before: Estado de voz anterior
            after: Novo estado de voz
        """
        try:
            # Importar e usar o handler do events.py
            from events import on_voice_state_update as voice_handler
            await voice_handler(member, before, after)
        except ImportError:
            logger.warning('M√≥dulo events.py n√£o encontrado. Handler de voz n√£o dispon√≠vel.')
        except Exception as e:
            logger.error(f'Erro no handler de voice state: {e}', exc_info=True)

    # Registrar comando de ranking
    @bot.command(name='rankingvideo')
    async def ranking_video_command(ctx: commands.Context) -> None:
        """
        Comando para exibir o ranking de tempo com c√¢mera ligada.

        Conforme RF04 do PRD, exibe top 10 usu√°rios por tempo de c√¢mera.

        Args:
            ctx: Contexto do comando Discord
        """
        try:
            # Importar aqui para evitar import circular
            from commands import ranking_video
            await ranking_video(ctx)
        except ImportError:
            logger.warning('M√≥dulo commands.py n√£o encontrado. Comando ranking n√£o dispon√≠vel.')
            await ctx.send('Comando indispon√≠vel no momento. Contate o administrador.')
        except Exception as e:
            logger.error(f'Erro no comando rankingvideo: {e}', exc_info=True)
            await ctx.send('Erro ao processar comando. Tente novamente mais tarde.')

    @bot.event
    async def on_command_error(ctx: commands.Context, error: Exception) -> None:
        """
        Evento chamado quando ocorre um erro em um comando.

        Fornece tratamento de erro amig√°vel para o usu√°rio e loga o erro.

        Args:
            ctx: Contexto do comando que falhou
            error: Exce√ß√£o que causou o erro
        """
        if isinstance(error, commands.CommandNotFound):
            # Ignorar silenciosamente comandos n√£o encontrados
            return

        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(f'Argumento faltando: {error.param.name}')
            return

        if isinstance(error, commands.BadArgument):
            await ctx.send(f'Argumento inv√°lido fornecido.')
            return

        # Logar outros erros
        logger.error(f'Erro no comando {ctx.command}: {error}', exc_info=True)
        await ctx.send('Ocorreu um erro ao executar o comando.')

    return bot


def run_bot() -> NoReturn:
    """
    Inicializa e executa o bot Discord.

    Carrega o token do ambiente, cria o bot e inicia a conex√£o.
    Implementa shutdown graceful e tratamento de erros cr√≠ticos.

    Raises:
        SystemExit: Se o token n√£o estiver configurado
    """
    if not DISCORD_TOKEN:
        logger.error('DISCORD_TOKEN n√£o encontrado no arquivo .env')
        logger.error('Crie um arquivo .env baseado no .env.example')
        sys.exit(1)

    bot = create_bot()

    try:
        logger.info('Iniciando bot...')
        bot.run(DISCORD_TOKEN)
    except discord.LoginFailure:
        logger.error('Falha na autentica√ß√£o. Verifique o DISCORD_TOKEN no arquivo .env')
        sys.exit(1)
    except discord.ConnectionClosed as e:
        logger.error(f'Conex√£o com Discord fechada: {e}')
        sys.exit(1)
    except KeyboardInterrupt:
        logger.info('Bot interrompido pelo usu√°rio')
        sys.exit(0)
    except Exception as e:
        logger.error(f'Erro inesperado ao executar bot: {e}', exc_info=True)
        sys.exit(1)


if __name__ == '__main__':
    run_bot()
</file>

<file path="commands.py">
"""
Comandos do bot Discord de ranking de atividade.

Este modulo implementa os comandos disponiveis para os usuarios,
incluindo o comando !rankingvideo conforme RF04 e secao 4.4.3 do PRD.
"""

import discord
from discord.ext import commands
from typing import List, Tuple

from config import EMBED_COLOR, MAX_RANKING_SIZE
from database import load_data
from utils import fetch_user, format_seconds_to_time, truncate_string


async def ranking_video(ctx: commands.Context) -> None:
    """
    Comando !rankingvideo - Exibe o top 10 usuarios por tempo com camera.

    Conforme RF04 e secao 6.1 do PRD:
    - Exibe top 10 usuarios por tempo com camera
    - Formato: Embed Discord com estilizacao
    - Informacoes: posicao, nome/avatar, tempo total (Xh Ymin), numero de sessoes
    - Ordenacao: Decrescente por total_seconds
    - Resposta quando vazio: Mensagem amigavel

    Args:
        ctx: Contexto do comando Discord

    Example:
        >>> !rankingvideo
        # Exibe embed com o ranking
    """
    # Carregar dados do JSON
    data = load_data()

    # Verificar se ha dados (RF04 - caso vazio)
    if not data:
        empty_message = (
            "üé• **Ranking - Tempo com C√¢mera Ligada**\n\n"
            "Ainda n√£o h√° dados de sess√µes registradas.\n"
            "Seja o primeiro a ligar a c√¢mera! üìπ"
        )
        await ctx.send(empty_message)
        return

    # Ordenar por total_seconds decrescente e pegar top 10
    sorted_users: List[Tuple[str, int]] = sorted(
        data.items(),
        key=lambda item: item[1]["total_seconds"],
        reverse=True
    )[:MAX_RANKING_SIZE]

    # Criar embed com cor #5865F2 (Azul Discord)
    embed = discord.Embed(
        title="üé• Ranking - Tempo com C√¢mera Ligada",
        color=EMBED_COLOR
    )

    # Adicionar campos para cada usuario no ranking
    guild = ctx.guild
    position = 1

    for user_id, user_data in sorted_users:
        # Buscar informacoes do usuario
        member = await fetch_user(guild, user_id)

        # Skip silencioso para usuarios inexistentes (RNF06)
        if member is None:
            continue

        # Formatar tempo
        total_time = format_seconds_to_time(user_data["total_seconds"])
        sessions = user_data["sessions"]

        # Criar nome do usuario com posicao
        name = f"#{position} {member.display_name}"
        name = truncate_string(name, 50)

        # Criar valor com tempo e sessoes
        value = f"‚è±Ô∏è {total_time}\nüìπ {sessions} sess√£o(√µes)"

        # Adicionar campo ao embed
        embed.add_field(
            name=name,
            value=value,
            inline=False
        )

        position += 1

    # Adicionar rodape com informacoes do servidor
    embed.set_footer(
        text=f"Servidor: {guild.name} | Total de {len(data)} usu√°rios registrados"
    )

    # Adicionar thumbnail com icone do servidor se disponivel
    if guild.icon:
        embed.set_thumbnail(url=guild.icon.url)

    # Enviar embed
    await ctx.send(embed=embed)


# Configurar comandos para o bot
def setup_commands(bot: commands.Bot) -> None:
    """
    Registra os comandos do bot.

    Args:
        bot: Instancia do bot Discord
    """
    bot.command(name="rankingvideo")(ranking_video)
</file>

<file path="config.py">
"""
Configura√ß√µes e constantes do bot Discord de ranking.

Este m√≥dulo centraliza todas as configura√ß√µes do bot, incluindo:
- Carregamento de vari√°veis de ambiente via .env
- Constantes do projeto (prefixo, caminhos, cores)
- Configura√ß√£o de Intents do Discord
- Configura√ß√£o de logger estruturado
"""
from os import getenv
from logging import INFO, basicConfig, getLogger, Logger
from typing import Optional

import discord
from dotenv import load_dotenv

# Carregar vari√°veis de ambiente do arquivo .env
load_dotenv()

# ============================================================================
# CONSTANTES DO PROJETO
# ============================================================================

DISCORD_TOKEN: str = getenv("DISCORD_TOKEN", "")
COMMAND_PREFIX: str = getenv("COMMAND_PREFIX", "!")

# Arquivo de persist√™ncia de dados
DATA_FILE: str = "video_ranking.json"

# Configura√ß√µes do Embed de ranking
EMBED_COLOR: int = 0x5865F2  # Azul Discord (#5865F2)
MAX_RANKING_SIZE: int = 10

# Formato de tempo para logs
TIME_FORMAT: str = "%Y-%m-%d %H:%M:%S"


# ============================================================================
# CONFIGURA√á√ÉO DE INTENTS
# ============================================================================

def get_intents() -> discord.Intents:
    """
    Configura e retorna os Intents necess√°rios para o bot.

    Os Intents definem quais eventos o bot pode receber do Discord.
    Para rastreamento de c√¢mera, precisamos de:
    - guilds: Para opera√ß√µes b√°sicas de servidor
    - voice_states: Para detectar mudan√ßas de estado de voz (c√¢mera)
    - members: Para buscar informa√ß√µes de usu√°rios (fetch_user)

    Returns:
        discord.Intents: Objeto de Intents configurado para o bot.

    Example:
        >>> intents = get_intents()
        >>> bot = commands.Bot(command_prefix="!", intents=intents)
    """
    intents = discord.Intents.default()
    intents.guilds = True
    intents.voice_states = True
    intents.members = True  # Necess√°rio para fetch_user em ranking
    return intents


# ============================================================================
# CONFIGURA√á√ÉO DE LOGGER
# ============================================================================

def setup_logger(name: Optional[str] = None, level: int = INFO) -> Logger:
    """
    Configura e retorna um logger estruturado para o bot.

    O logger √© configurado com formato estruturado para facilitar debug
    e monitoramento do bot em produ√ß√£o.

    Args:
        name: Nome do logger (default: None usa o logger root).
        level: N√≠vel de log (default: INFO).

    Returns:
        Logger: Objeto de logger configurado.

    Example:
        >>> logger = setup_logger("bot")
        >>> logger.info("Bot iniciado com sucesso")
    """
    basicConfig(
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt=TIME_FORMAT,
        level=level,
    )
    return getLogger(name or __name__)
</file>

<file path="database.py">
"""
M√≥dulo de persist√™ncia de dados para o bot de ranking Discord.

Este m√≥dulo implementa fun√ß√µes para carregar, salvar e atualizar
dados de ranking de tempo de c√¢mera no formato JSON, conforme
RF06 e se√ß√£o 4.4.2 do PRD.
"""

from pathlib import Path
from typing import Dict, Any
import json


# Caminho do arquivo JSON de dados
DATA_FILE = Path("video_ranking.json")


def load_data() -> Dict[str, Dict[str, int]]:
    """
    Carrega os dados de ranking do arquivo JSON.
    
    Conforme RF06: L√™ o arquivo video_ranking.json e retorna
    o dicion√°rio com dados de todos os usu√°rios.
    
    Returns:
        Dict[str, Dict[str, int]]: Dicion√°rio onde a chave √© o user_id
            e o valor √© um dict com 'total_seconds' e 'sessions'.
            Retorna dict vazio se arquivo n√£o existir ou estiver vazio.
    
    Example:
        >>> data = load_data()
        >>> data["123456789"]
        {'total_seconds': 3600, 'sessions': 5}
    """
    if not DATA_FILE.exists():
        # Criar arquivo vazio conforme RF06
        save_data({})
        return {}
    
    try:
        with open(DATA_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
            # Validar estrutura b√°sica
            if not isinstance(data, dict):
                return {}
            return data
    except (json.JSONDecodeError, ValueError):
        # Arquivo corrompido - recriar vazio
        save_data({})
        return {}


def save_data(data: Dict[str, Dict[str, int]]) -> None:
    """
    Salva os dados de ranking no arquivo JSON.
    
    Conforme RNF12: Usa indent=2 para legibilidade do arquivo JSON.
    
    Args:
        data: Dicion√°rio com dados dos usu√°rios no formato:
            {
                "user_id": {
                    "total_seconds": int,
                    "sessions": int
                }
            }
    
    Example:
        >>> save_data({"123": {"total_seconds": 100, "sessions": 1}})
    """
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def update_video_time(user_id: str, duration: int) -> None:
    """
    Atualiza o tempo acumulado de c√¢mera para um usu√°rio.
    
    Carrega os dados atuais, adiciona a dura√ß√£o ao total do usu√°rio
    e incrementa o contador de sess√µes. Salva o arquivo atualizado.
    
    Args:
        user_id: ID do usu√°rio Discord (string)
        duration: Dura√ß√£o da sess√£o em segundos (int > 0)
    
    Raises:
        ValueError: Se duration for negativo
    
    Example:
        >>> update_video_time("123456789", 1800)  # 30 minutos
        >>> data = load_data()
        >>> data["123456789"]["sessions"]
        1
    """
    if duration < 0:
        raise ValueError("duration must be non-negative")
    
    data = load_data()
    
    if user_id not in data:
        # Nova entrada para o usu√°rio
        data[user_id] = {
            "total_seconds": duration,
            "sessions": 1
        }
    else:
        # Atualizar entrada existente
        data[user_id]["total_seconds"] += duration
        data[user_id]["sessions"] += 1
    
    save_data(data)


# Inicializa√ß√£o: criar arquivo vazio se n√£o existir
if not DATA_FILE.exists():
    save_data({})
</file>

<file path="events.py">
"""
events.py - Event handlers para o bot Discord de ranking de atividade.

Este m√≥dulo cont√©m os handlers de eventos do Discord, focando principalmente
no rastreamento de c√¢mera ligada atrav√©s de on_voice_state_update.

Se√ß√£o 4.4.1 do PRD: Event Handler - Voice State
"""

import logging
from datetime import datetime
from typing import Dict, Optional

import discord
from discord.ext import commands

# Configura√ß√£o de logging conforme se√ß√£o 6.2 do PRD
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Estrutura de sess√µes ativas conforme RF07 do PRD
# active_video_sessions = {
#     "user_id": datetime_object
# }
active_video_sessions: Dict[str, datetime] = {}


async def on_voice_state_update(
    member: discord.Member,
    before: discord.VoiceState,
    after: discord.VoiceState
) -> None:
    """
    Handler para mudan√ßas no estado de voz dos membros.

    Detecta mudan√ßas em self_video e rastreia tempo de c√¢mera ligada.

    Args:
        member: O membro do Discord cujo estado mudou
        before: Estado de voz anterior
        after: Estado de voz atual

    Comportamento (UC01/UC02 - se√ß√£o 5 do PRD):
        1. Detecta self_video = True -> Salva timestamp
        2. Detecta self_video = False -> Calcula dura√ß√£o -> Atualiza JSON
    """
    # Detecta quando usu√°rio liga a c√¢mera (UC01)
    if not before.self_video and after.self_video:
        user_id = str(member.id)
        active_video_sessions[user_id] = datetime.now()

        # Log conforme se√ß√£o 6.2 do PRD
        logger.info(f"üìπ {member.display_name} ligou a c√¢mera")

    # Detecta quando usu√°rio desliga a c√¢mera (UC02)
    elif before.self_video and not after.self_video:
        user_id = str(member.id)

        # Verifica se h√° sess√£o ativa para este usu√°rio
        if user_id in active_video_sessions:
            # Calcula dura√ß√£o da sess√£o
            start_time = active_video_sessions[user_id]
            duration = datetime.now() - start_time
            duration_seconds = int(duration.total_seconds())

            # Remove sess√£o ativa
            del active_video_sessions[user_id]

            # Atualiza dados persistentes via database.py
            _update_video_time(user_id, duration_seconds)

            # Log conforme se√ß√£o 6.2 do PRD
            logger.info(f"üìπ {member.display_name} desligou - {duration_seconds}s gravados")


def _update_video_time(user_id: str, duration: int) -> None:
    """
    Atualiza o tempo de v√≠deo do usu√°rio no JSON.

    Fun√ß√£o stub que ser√° substitu√≠da pela implementa√ß√£o em database.py.
    Mantida aqui para permitir que events.py funcione de forma aut√¥noma.

    Args:
        user_id: ID do usu√°rio Discord como string
        duration: Dura√ß√£o da sess√£o em segundos

    Note:
        Esta fun√ß√£o ser√° removida quando database.py for implementado,
        pois a funcionalidade ser√° importada de l√°.
    """
    import json
    import os
    from pathlib import Path

    json_path = Path(__file__).parent / "video_ranking.json"

    # Carrega dados existentes
    if json_path.exists():
        with open(json_path, 'r', encoding='utf-8') as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                data = {}
    else:
        data = {}

    # Atualiza dados do usu√°rio
    if user_id not in data:
        data[user_id] = {"total_seconds": 0, "sessions": 0}

    data[user_id]["total_seconds"] += duration
    data[user_id]["sessions"] += 1

    # Salva dados atualizados (indent=2 conforme RNF12)
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def setup(bot: commands.Bot) -> None:
    """
    Registra os event handlers no bot.

    Args:
        bot: Inst√¢ncia do bot Discord
    """
    bot.add_listener(on_voice_state_update, 'on_voice_state_update')


# Type hints para todos os componentes (RNF10)
__all__ = [
    'active_video_sessions',
    'on_voice_state_update',
    'setup',
]
</file>

<file path="PRD.md">
Vou criar um PRD (Product Requirements Document) completo para o projeto de bot Discord de ranking de atividade:

```markdown
# Product Requirements Document (PRD)
## Bot de Ranking de Atividade Discord

---

## 1. Vis√£o Geral do Projeto

### 1.1 Contexto
Bot Discord para rastreamento e ranking de atividade de membros em servidores, com foco principal em tempo de participa√ß√£o com c√¢mera ligada em canais de voz.

### 1.2 Objetivo
Gamificar e incentivar a participa√ß√£o ativa dos membros atrav√©s de m√©tricas vis√≠veis de engajamento, especialmente uso de c√¢mera em reuni√µes/chamadas.

### 1.3 Escopo
- **P√∫blico-alvo**: Servidores Discord com at√© 50 membros ativos
- **Plataforma**: Discord (desktop/mobile/web)
- **Tecnologia**: Python 3.10+, discord.py 2.x, JSON para persist√™ncia

---

## 2. Requisitos Funcionais

### 2.1 Rastreamento de Atividade

#### RF01 - Rastreamento de Tempo com C√¢mera
**Prioridade**: Alta
**Descri√ß√£o**: O bot deve rastrear automaticamente quando usu√°rios ligam/desligam c√¢mera em canais de voz.

**Crit√©rios de Aceita√ß√£o**:
- Detectar evento `self_video = True` no `on_voice_state_update`
- Registrar timestamp de in√≠cio quando c√¢mera √© ligada
- Calcular dura√ß√£o quando c√¢mera √© desligada
- Acumular tempo total por usu√°rio
- Registrar n√∫mero de sess√µes com c√¢mera

**M√©tricas Rastreadas**:
- `total_seconds`: Tempo acumulado em segundos
- `sessions`: N√∫mero de vezes que ligou c√¢mera
- `last_updated`: Timestamp da √∫ltima atividade

#### RF02 - Rastreamento de Tempo em Voz (Opcional - Fase 2)
**Prioridade**: M√©dia
**Descri√ß√£o**: Rastrear tempo total em canais de voz (com ou sem c√¢mera).

#### RF03 - Rastreamento de Mensagens (Opcional - Fase 2)
**Prioridade**: Baixa
**Descri√ß√£o**: Contar mensagens enviadas por usu√°rio.

### 2.2 Sistema de Ranking

#### RF04 - Comando de Leaderboard
**Prioridade**: Alta
**Comando**: `!rankingvideo`

**Funcionalidade**:
- Exibir top 10 usu√°rios por tempo com c√¢mera
- Formato: Embed Discord com estiliza√ß√£o
- Informa√ß√µes por usu√°rio:
  - Posi√ß√£o no ranking (#1, #2, etc.)
  - Nome/avatar do usu√°rio
  - Tempo total (formato: Xh Ymin)
  - N√∫mero de sess√µes
- Ordena√ß√£o: Decrescente por `total_seconds`

**Resposta quando vazio**: Mensagem amig√°vel informando aus√™ncia de dados

#### RF05 - Comando de Estat√≠sticas Individual (Opcional - Fase 2)
**Prioridade**: Baixa
**Comando**: `!meustats` ou `!stats @usuario`

**Funcionalidade**:
- Exibir estat√≠sticas detalhadas de um usu√°rio espec√≠fico
- Informa√ß√µes: ranking atual, tempo total, sess√µes, m√©dia por sess√£o

### 2.3 Persist√™ncia de Dados

#### RF06 - Armazenamento JSON
**Prioridade**: Alta
**Arquivo**: `video_ranking.json`

**Estrutura**:
```json
{
  "user_id_1": {
    "total_seconds": 3600,
    "sessions": 5
  },
  "user_id_2": {
    "total_seconds": 7200,
    "sessions": 10
  }
}
```

**Opera√ß√µes**:
- Leitura: Ao iniciar comandos de ranking
- Escrita: Sempre que uma sess√£o de c√¢mera termina
- Inicializa√ß√£o: Criar arquivo vazio {} se n√£o existir

#### RF07 - Gest√£o de Sess√µes Ativas
**Prioridade**: Alta
**Descri√ß√£o**: Manter dicion√°rio em mem√≥ria com sess√µes ativas.

**Estrutura**:
```python
active_video_sessions = {
  "user_id": datetime_object
}
```

**Comportamento**:
- Adicionar entrada quando c√¢mera liga
- Remover e calcular dura√ß√£o quando c√¢mera desliga
- Limpar se usu√°rio sai do servidor/canal abruptamente

---

## 3. Requisitos N√£o-Funcionais

### 3.1 Performance
- **RNF01**: Resposta de comandos em < 2 segundos para 50 usu√°rios
- **RNF02**: Arquivo JSON deve ter < 10KB para 50 usu√°rios
- **RNF03**: Bot deve usar < 100MB de RAM em opera√ß√£o normal

### 3.2 Confiabilidade
- **RNF04**: Disponibilidade de 99% (m√≠nimo 23h45min/dia)
- **RNF05**: N√£o perder dados de sess√µes conclu√≠das mesmo em restart
- **RNF06**: Tratamento de erros para usu√°rios inexistentes/deletados

### 3.3 Seguran√ßa
- **RNF07**: Token do bot em vari√°vel de ambiente (.env)
- **RNF08**: Permiss√µes m√≠nimas necess√°rias (intents: guilds, voice_states)
- **RNF09**: Valida√ß√£o de IDs de usu√°rio antes de queries

### 3.4 Manutenibilidade
- **RNF10**: C√≥digo em Python com type hints
- **RNF11**: Logs estruturados para debug (console)
- **RNF12**: Arquivo JSON leg√≠vel (indent=2)
- **RNF13**: Fun√ß√µes modulares e reutiliz√°veis

### 3.5 Escalabilidade
- **RNF14**: Preparado para migra√ß√£o futura para SQLite se > 100 usu√°rios
- **RNF15**: Estrutura de dados extens√≠vel para novas m√©tricas

---

## 4. Arquitetura T√©cnica

### 4.1 Stack Tecnol√≥gico
- **Linguagem**: Python 3.10+
- **Biblioteca Discord**: discord.py 2.3+
- **Persist√™ncia**: JSON (biblioteca nativa `json`)
- **Gest√£o de tempo**: `datetime` (biblioteca nativa)
- **Deploy**: VPS Ubuntu 22.04+ ou container Docker

### 4.2 Intents Necess√°rios
```python
intents = discord.Intents.default()
intents.guilds = True
intents.voice_states = True
intents.members = True  # Para fetch_user
```

### 4.3 Estrutura de Arquivos
```
discord-ranking-bot/
‚îú‚îÄ‚îÄ bot.py              # Arquivo principal
‚îú‚îÄ‚îÄ config.py           # Configura√ß√µes e constantes
‚îú‚îÄ‚îÄ database.py         # Fun√ß√µes de persist√™ncia
‚îú‚îÄ‚îÄ commands.py         # Comandos do bot
‚îú‚îÄ‚îÄ events.py           # Event handlers
‚îú‚îÄ‚îÄ utils.py            # Fun√ß√µes auxiliares
‚îú‚îÄ‚îÄ .env                # Vari√°veis de ambiente
‚îú‚îÄ‚îÄ requirements.txt    # Depend√™ncias
‚îú‚îÄ‚îÄ video_ranking.json  # Dados (gerado automaticamente)
‚îî‚îÄ‚îÄ README.md          # Documenta√ß√£o
```

### 4.4 Componentes Principais

#### 4.4.1 Event Handler - Voice State
```python
@bot.event
async def on_voice_state_update(member, before, after)
```
- Detecta mudan√ßas em `self_video`
- Registra timestamps de in√≠cio/fim
- Atualiza JSON ao fim de sess√£o

#### 4.4.2 Data Manager
```python
def load_data() -> dict
def save_data( dict) -> None
def update_video_time(user_id: str, duration: int) -> None
```

#### 4.4.3 Command Handler - Ranking
```python
@bot.command(name='rankingvideo')
async def ranking_video(ctx)
```
- Carrega dados do JSON
- Ordena por `total_seconds`
- Formata e envia embed

---

## 5. Casos de Uso

### UC01 - Usu√°rio Liga C√¢mera
**Ator**: Membro do servidor
**Fluxo**:
1. Usu√°rio entra em canal de voz
2. Usu√°rio ativa c√¢mera
3. Bot detecta `self_video = True`
4. Bot salva timestamp em `active_video_sessions`
5. Bot loga a√ß√£o no console

**Resultado**: In√≠cio de rastreamento registrado

### UC02 - Usu√°rio Desliga C√¢mera
**Ator**: Membro do servidor
**Fluxo**:
1. Usu√°rio desativa c√¢mera
2. Bot detecta `self_video = False`
3. Bot calcula dura√ß√£o: `datetime.now() - start_time`
4. Bot atualiza JSON com dura√ß√£o acumulada
5. Bot incrementa contador de sess√µes
6. Bot remove entrada de `active_video_sessions`
7. Bot loga dura√ß√£o no console

**Resultado**: Tempo registrado e persistido

### UC03 - Administrador Consulta Ranking
**Ator**: Administrador ou membro
**Fluxo**:
1. Usu√°rio digita `!rankingvideo`
2. Bot carrega `video_ranking.json`
3. Bot ordena usu√°rios por `total_seconds`
4. Bot busca informa√ß√µes dos top 10 usu√°rios
5. Bot cria embed formatado
6. Bot envia embed no canal

**Fluxo Alternativo**: Se JSON vazio, envia mensagem de aus√™ncia de dados

**Resultado**: Ranking exibido visualmente

### UC04 - Bot Reinicia Durante Sess√£o Ativa
**Ator**: Sistema
**Fluxo**:
1. Bot est√° rastreando sess√µes ativas em mem√≥ria
2. Bot √© desligado/reiniciado
3. Sess√µes ativas em `active_video_sessions` s√£o perdidas
4. Bot reinicia e aguarda novos eventos

**Problema Conhecido**: Sess√µes ativas n√£o persistem
**Solu√ß√£o Futura (Fase 2)**: Salvar sess√µes ativas periodicamente

---

## 6. Interface do Usu√°rio

### 6.1 Embed de Ranking
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üé• Ranking - Tempo com C√¢mera Ligada‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ #1 Jo√£o Silva                       ‚îÇ
‚îÇ ‚è±Ô∏è 12h 35min                        ‚îÇ
‚îÇ üìπ 23 sess√µes                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ #2 Maria Santos                     ‚îÇ
‚îÇ ‚è±Ô∏è 8h 42min                         ‚îÇ
‚îÇ üìπ 15 sess√µes                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ... (at√© 10 posi√ß√µes)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Cores**: Azul Discord (#5865F2)
**√çcones**: üé• üìπ ‚è±Ô∏è
**Formato**: `inline=False` para melhor legibilidade

### 6.2 Logs do Console
```
üìπ Jo√£o Silva ligou a c√¢mera
üìπ Maria Santos ligou a c√¢mera
üìπ Jo√£o Silva desligou - 1847s gravados
‚úÖ Bot conectado como RankingBot#1234
```

---

## 7. Depend√™ncias

### 7.1 requirements.txt
```
discord.py>=2.3.0
python-dotenv>=1.0.0
```

### 7.2 Vari√°veis de Ambiente (.env)
```
DISCORD_TOKEN=seu_token_aqui
COMMAND_PREFIX=!
```

---

## 8. Roadmap de Desenvolvimento

### Fase 1 - MVP (Semana 1)
- ‚úÖ Setup b√°sico do bot
- ‚úÖ Event handler para `self_video`
- ‚úÖ Persist√™ncia JSON
- ‚úÖ Comando `!rankingvideo`
- ‚úÖ Logs b√°sicos

### Fase 2 - Melhorias (Semana 2-3)
- ‚¨ú Persist√™ncia de sess√µes ativas
- ‚¨ú Comando `!meustats`
- ‚¨ú Rastreamento de tempo em voz
- ‚¨ú Sistema de backup autom√°tico
- ‚¨ú Comando admin para reset de dados

### Fase 3 - Expans√£o (Futuro)
- ‚¨ú Rastreamento de mensagens
- ‚¨ú Sistema de XP e n√≠veis
- ‚¨ú Atribui√ß√£o autom√°tica de cargos
- ‚¨ú Dashboard web
- ‚¨ú Migra√ß√£o para PostgreSQL

---

## 9. Riscos e Mitiga√ß√µes

| Risco | Probabilidade | Impacto | Mitiga√ß√£o |
|-------|--------------|---------|-----------|
| Perda de dados por crash | M√©dia | Alto | Salvar imediatamente ap√≥s cada sess√£o |
| Bot offline durante eventos | Baixa | M√©dio | Monitoramento com uptime service |
| Spam de comandos | Baixa | Baixo | Cooldown de 5s por usu√°rio |
| JSON corrompido | Baixa | Alto | Backup di√°rio + valida√ß√£o na leitura |
| Usu√°rio deleta conta | M√©dia | Baixo | Try/except em fetch_user |

---

## 10. M√©tricas de Sucesso

### 10.1 KPIs T√©cnicos
- Uptime: > 99%
- Tempo de resposta: < 2s
- Taxa de erro: < 0.1%

### 10.2 KPIs de Produto
- Usu√°rios rastreados: 50 (meta)
- Comandos executados/dia: 10+
- Sess√µes de c√¢mera/dia: 20+

### 10.3 KPIs de Engajamento
- Aumento de 30% no uso de c√¢mera ap√≥s 1 m√™s
- 80% dos membros ativos consultam ranking semanalmente

---

## 11. Testes

### 11.1 Casos de Teste

**TC01 - Rastreamento B√°sico**
- Usu√°rio liga c√¢mera ‚Üí timestamp registrado
- Usu√°rio desliga c√¢mera ‚Üí dura√ß√£o calculada corretamente
- Verificar JSON atualizado com valores corretos

**TC02 - Ranking Vazio**
- Deletar JSON ou usar JSON vazio
- Executar `!rankingvideo`
- Verificar mensagem de aus√™ncia de dados

**TC03 - Ranking com Dados**
- Popular JSON com 3 usu√°rios
- Executar `!rankingvideo`
- Verificar ordena√ß√£o correta

**TC04 - M√∫ltiplas Sess√µes**
- Usu√°rio liga/desliga c√¢mera 3x
- Verificar `sessions = 3`
- Verificar soma correta de `total_seconds`

**TC05 - Usu√°rio Inexistente**
- Adicionar user_id inv√°lido no JSON
- Executar `!rankingvideo`
- Verificar skip silencioso sem erro

### 11.2 Testes de Carga
- 10 usu√°rios simult√¢neos com c√¢mera
- 50 consultas de ranking em 1 minuto
- Verificar aus√™ncia de race conditions

---

## 12. Documenta√ß√£o

### 12.1 README.md (Obrigat√≥rio)
- Descri√ß√£o do projeto
- Requisitos e instala√ß√£o
- Configura√ß√£o (.env)
- Comandos dispon√≠veis
- Como executar
- Troubleshooting

### 12.2 Coment√°rios no C√≥digo
- Docstrings em todas as fun√ß√µes
- Type hints em par√¢metros e retornos
- Coment√°rios explicando l√≥gica complexa

---

## 13. Deploy

### 13.1 Ambiente de Desenvolvimento
- Python 3.10+ local
- Servidor Discord de testes
- Bot com permiss√µes de dev

### 13.2 Ambiente de Produ√ß√£o
**Op√ß√£o 1: VPS Ubuntu**
- Instalar Python 3.10+
- Clonar reposit√≥rio
- Configurar .env
- Executar com systemd ou screen

**Op√ß√£o 2: Docker**
```dockerfile
FROM python:3.10-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "bot.py"]
```

**Op√ß√£o 3: Railway/Render**
- Deploy autom√°tico via GitHub
- Vari√°veis de ambiente na plataforma

---

## 14. Permiss√µes Discord Necess√°rias

### 14.1 Bot Permissions
- View Channels
- Read Message History
- Send Messages
- Embed Links

### 14.2 Privileged Gateway Intents
- Server Members Intent (para fetch_user)
- Presence Intent (opcional - para status)

### 14.3 OAuth2 URL
```
https://discord.com/api/oauth2/authorize?client_id=YOUR_BOT_ID&permissions=19456&scope=bot
```

---

## 15. Gloss√°rio

- **Self Video**: Estado do Discord que indica se c√¢mera est√° ligada
- **Voice State Update**: Evento disparado quando h√° mudan√ßa em canal de voz
- **Embed**: Mensagem formatada rica do Discord
- **Intents**: Permiss√µes de eventos que o bot pode receber
- **Guild**: Servidor Discord (terminologia da API)

---

## 16. Aprova√ß√µes

| Stakeholder | Papel | Status | Data |
|-------------|-------|--------|------|
| Gabriel Ramos | Product Owner | ‚úÖ Aprovado | 08/02/2026 |
| - | Tech Lead | Pendente | - |
| - | QA | Pendente | - |

---

## 17. Hist√≥rico de Vers√µes

| Vers√£o | Data | Autor | Mudan√ßas |
|--------|------|-------|----------|
| 1.0 | 08/02/2026 | Perplexity AI | Vers√£o inicial do PRD |

---

## 18. Anexos

### Anexo A - Exemplo de JSON
```json
{
  "123456789012345678": {
    "total_seconds": 45320,
    "sessions": 12
  },
  "987654321098765432": {
    "total_seconds": 31450,
    "sessions": 8
  }
}
```

### Anexo B - C√≥digo M√≠nimo Vi√°vel
(Refer√™ncia ao c√≥digo fornecido anteriormente na conversa)
```

Este PRD est√° pronto para ser usado como documento base do projeto. Ele cobre todos os aspectos necess√°rios desde requisitos t√©cnicos at√© m√©tricas de sucesso, passando por arquitetura, casos de uso e roadmap de desenvolvimento.[1][2]

Fontes
[1] How to create a Discord bot with Python: Part 11 - Connect a sqlite3 database https://www.youtube.com/watch?v=H09U2E2v8eg
[2] JSON file VS SQLite android https://stackoverflow.com/questions/8652005/json-file-vs-sqlite-android
</file>

<file path="requirements.txt">
discord.py>=2.3.0
python-dotenv>=1.0.0
</file>

<file path="utils.py">
"""
Funcoes utilitarias para o bot Discord de ranking de atividade.

Este modulo fornece funcoes auxiliares para formatacao de tempo,
validacao de dados e configuracao de logs estruturados.
"""

import logging
import re
import discord
from typing import Optional


def format_seconds_to_time(seconds: int) -> str:
    """
    Converte segundos em formato legivel.

    Formatos possiveis:
    - "Xh Ymin" para duracoes >= 1 hora
    - "Xmin" para duracoes >= 1 minuto
    - "Xs" para duracoes < 1 minuto

    Args:
        seconds: Tempo total em segundos (inteiro nao-negativo)

    Returns:
        String formatada representando o tempo

    Examples:
        >>> format_seconds_to_time(3665)
        '1h 1min'
        >>> format_seconds_to_time(120)
        '2min'
        >>> format_seconds_to_time(45)
        '45s'
    """
    if not isinstance(seconds, int) or seconds < 0:
        raise ValueError("seconds deve ser um inteiro nao-negativo")

    if seconds < 60:
        return f"{seconds}s"

    minutes = seconds // 60
    remaining_seconds = seconds % 60

    if minutes < 60:
        return f"{minutes}min"

    hours = minutes // 60
    remaining_minutes = minutes % 60

    if remaining_minutes == 0:
        return f"{hours}h"

    return f"{hours}h {remaining_minutes}min"


def validate_user_id(user_id: str) -> bool:
    """
    Valida se um ID de usuario Discord e valido.

    Conforme RNF09, IDs validos do Discord sao snowflakes de 18-19 digitos.
    Esta funcao implementa a validacao basica de formato.

    Args:
        user_id: String contendo o ID do usuario

    Returns:
        True se o ID tem formato valido, False caso contrario

    Examples:
        >>> validate_user_id("123456789012345678")
        True
        >>> validate_user_id("invalid")
        False
        >>> validate_user_id("12345")
        False
    """
    if not isinstance(user_id, str):
        return False

    # Discord snowflake IDs sao 18-19 digitos numericos
    pattern = r"^\d{18,19}$"
    return bool(re.match(pattern, user_id))


def validate_seconds(seconds: int) -> bool:
    """
    Valida se um valor em segundos e valido.

    Args:
        seconds: Valor em segundos a validar

    Returns:
        True se seconds e um inteiro nao-negativo, False caso contrario
    """
    return isinstance(seconds, int) and seconds >= 0


def setup_logger(
    name: str = "bate-ponto",
    level: int = logging.INFO,
    log_file: Optional[str] = None
) -> logging.Logger:
    """
    Configura um logger estruturado conforme RNF11.

    Formata logs com timestamp, nivel, nome do modulo e mensagem.
    Suporta saida em console e/ou arquivo.

    Args:
        name: Nome do logger (default: "bate-ponto")
        level: Nivel de log (default: logging.INFO)
        log_file: Caminho opcional para arquivo de log

    Returns:
        Logger configurado e pronto para uso

    Examples:
        >>> logger = setup_logger()
        >>> logger.info("Bot iniciado")
    """
    logger = logging.getLogger(name)
    logger.setLevel(level)

    # Evitar handlers duplicados
    if logger.handlers:
        logger.handlers.clear()

    formatter = logging.Formatter(
        fmt="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )

    # Handler para console
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Handler opcional para arquivo
    if log_file:
        file_handler = logging.FileHandler(log_file, encoding="utf-8")
        file_handler.setLevel(level)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

    return logger


def safe_int(value: str, default: int = 0) -> int:
    """
    Converte string para int de forma segura.

    Args:
        value: String a converter
        default: Valor padrao em caso de erro

    Returns:
        Inteiro convertido ou valor padrao
    """
    try:
        return int(value)
    except (ValueError, TypeError):
        return default


def truncate_string(text: str, max_length: int = 50, suffix: str = "...") -> str:
    """
    Trunca uma string se exceder o tamanho maximo.

    Args:
        text: Texto a truncar
        max_length: Comprimento maximo permitido
        suffix: Sufixo a adicionar quando truncado

    Returns:
        String truncada ou original se dentro do limite
    """
    if not isinstance(text, str):
        return ""

    if len(text) <= max_length:
        return text

    return text[:max_length - len(suffix)] + suffix


async def fetch_user(guild: discord.Guild, user_id: str) -> Optional[discord.Member]:
    """
    Busca informacoes de um usuario pelo ID.

    Conforme RNF06: Tratamento de erros para usuarios inexistentes/deletados.
    Esta funcao trata excecoes silenciosamente, retornando None quando o
    usuario nao pode ser encontrado.

    Args:
        guild: Objeto Guild do Discord onde buscar o usuario
        user_id: ID do usuario a buscar (string)

    Returns:
        Optional[discord.Member]: Objeto Member ou None se nao encontrado.

    Example:
        >>> member = await fetch_user(guild, "123456789012345678")
        >>> if member:
        ...     print(member.display_name)
    """
    try:
        return await guild.fetch_member(user_id)
    except (discord.NotFound, discord.HTTPException):
        return None
</file>

<file path="video_ranking.json">
{}
</file>

<file path="README.md">
# Bate-Ponto Discord Bot

![Python](https://img.shields.io/badge/Python-3.10%2B-blue)
![Discord](https://img.shields.io/badge/Discord.py-2.3%2B-purple)
![License](https://img.shields.io/badge/License-MIT-green)

## Sobre o Projeto

Bate-Ponto e um bot Discord que gamifica a participacao dos membros atraves de um ranking de atividade baseado em tempo de camera ligada em canais de voz. O objetivo e incentivar o engajamento visual em reunioes e chamadas, criando uma competencia saudavel entre membros.

### Funcionalidades Principais

- **Rastreamento automatico de camera**: Detecta quando usuarios ligam/desligam camera em tempo real
- **Sistema de ranking**: Leaderboard dos top 10 usuarios por tempo com camera
- **Persistencia de dados**: Armazenamento em JSON para garantir que dados nao sejam perdidos
- **Interface visual**: Embeds estilizados no Discord para melhor experiencia
- **Logs estruturados**: Console logging para monitoramento e debug

## Comandos Disponiveis

| Comando | Descricao | Uso |
|---------|-----------|-----|
| `!rankingvideo` | Exibe o top 10 usuarios por tempo de camera | `!rankingvideo` |

## Pre-requisitos

- **Python 3.10+**: Certifique-se de ter o Python instalado
- **Conta Discord**: Necessaria para criar o bot
- **Token do Bot**: Obtido no [Discord Developer Portal](https://discord.com/developers/applications)

## Instalacao

### 1. Clone o Repositorio

```bash
git clone https://github.com/seu-usuario/bate-ponto.git
cd bate-ponto
```

### 2. Crie um Ambiente Virtual (Opcional, mas Recomendado)

```bash
python -m venv .venv
source .venv/bin/activate  # Linux/Mac
# Ou
.venv\Scripts\activate     # Windows
```

### 3. Instale as Dependencias

```bash
pip install -r requirements.txt
```

Ou utilizando UV (recomendado):

```bash
uv pip install -r requirements.txt
```

## Configuracao

### 1. Configure as Variaveis de Ambiente

Copie o arquivo de exemplo:

```bash
cp .env.example .env
```

Edite o arquivo `.env` com suas credenciais:

```env
DISCORD_TOKEN=seu_token_aqui
COMMAND_PREFIX=!
```

### 2. Obtenha o Token do Bot

1. Acesse o [Discord Developer Portal](https://discord.com/developers/applications)
2. Crie uma nova aplicacao
3. Va em "Bot" e clique em "Add Bot"
4. Copie o token em "Reset Token"
5. Cole no arquivo `.env`

### 3. Configure as Permissoes do Bot

O bot precisa das seguintes permissoes:

- **View Channels** - Para acessar canais do servidor
- **Read Message History** - Para ler mensagens
- **Send Messages** - Para responder comandos
- **Embed Links** - Para exibir o ranking

### 4. Configure os Privileged Gateway Intents

No Discord Developer Portal, ative:

- **Server Members Intent** - Para buscar informacoes de usuarios
- **Presence Intent** (opcional) - Para detectar status

URL de convite com permissoes corretas:

```
https://discord.com/api/oauth2/authorize?client_id=YOUR_BOT_ID&permissions=19456&scope=bot%20applications.commands
```

## Como Executar

### Modo Desenvolvimento

```bash
python bot.py
```

Ou com UV:

```bash
uv run bot.py
```

### Modo Producao (Recomendado)

#### Usando systemd (Linux)

Crie o arquivo `/etc/systemd/system/bate-ponto.service`:

```ini
[Unit]
Description=Bate-Ponto Discord Bot
After=network.target

[Service]
Type=simple
User=seu-usuario
WorkingDirectory=/caminho/para/bate-ponto
Environment="PATH=/caminho/para/.venv/bin"
ExecStart=/caminho/para/.venv/bin/python bot.py
Restart=always

[Install]
WantedBy=multi-user.target
```

Execute:

```bash
sudo systemctl daemon-reload
sudo systemctl enable bate-ponto
sudo systemctl start bate-ponto
```

#### Usando Docker

```dockerfile
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "bot.py"]
```

Build e run:

```bash
docker build -t bate-ponto .
docker run -d --name bate-ponto --env-file .env bate-ponto
```

## Estrutura do Projeto

```
bate-ponto/
‚îú‚îÄ‚îÄ bot.py              # Arquivo principal do bot
‚îú‚îÄ‚îÄ .env                # Variaveis de ambiente (nao commitar)
‚îú‚îÄ‚îÄ .env.example        # Exemplo de configuracao
‚îú‚îÄ‚îÄ .gitignore          # Arquivos ignorados pelo git
‚îú‚îÄ‚îÄ requirements.txt    # Dependencias Python
‚îú‚îÄ‚îÄ video_ranking.json  # Dados do ranking (gerado automaticamente)
‚îú‚îÄ‚îÄ README.md           # Documentacao
‚îî‚îÄ‚îÄ PRD.md             # Product Requirements Document
```

## Troubleshooting

### Bot nao conecta

**Erro**: `LoginFailure: Improper token has been passed`

**Solucao**: Verifique se o token no `.env` esta correto e sem espacos extras.

### Comandos nao funcionam

**Erro**: Bot nao responde aos comandos

**Solucao**:
1. Verifique se o prefixo esta correto (default: `!`)
2. Confirme que o bot tem permissoes de "Send Messages"
3. Verifique se o bot esta online no servidor

### Erro de privilegios

**Erro**: `PrivilegedIntentsRequired`

**Solucao**: Ative os "Privileged Gateway Intents" no Discord Developer Portal.

### Dados nao sao salvos

**Erro**: `video_ranking.json` nao e atualizado

**Solucao**: Verifique as permissoes de escrita no diretorio do bot.

### Bot crasha com camera ligada

**Problema**: Sessoes ativas sao perdidas em restart

**Solucao**: E um comportamento conhecido. Sessoes ativas nao persistem por enquanto. A Fase 2 do projeto ira resolver isso.

### Permissao negada ao ler/escrever arquivo

**Erro**: `PermissionError: [Errno 13] Permission denied`

**Solucao**: Verifique as permissoes do diretorio:

```bash
chmod +w /caminho/para/bate-ponto
```

## Roadmap

### Fase 1 - MVP (Concluido)

- [x] Setup basico do bot
- [x] Event handler para `self_video`
- [x] Persistencia JSON
- [x] Comando `!rankingvideo`
- [x] Logs basicos

### Fase 2 - Melhorias (Planejado)

- [ ] Persistencia de sessoes ativas
- [ ] Comando `!meustats` (estatisticas individuais)
- [ ] Rastreamento de tempo em voz
- [ ] Sistema de backup automatico
- [ ] Comando admin para reset de dados
- [ ] Cooldown em comandos

### Fase 3 - Expansao (Futuro)

- [ ] Rastreamento de mensagens
- [ ] Sistema de XP e niveis
- [ ] Atribuicao automatica de cargos
- [ ] Dashboard web
- [ ] Migracao para PostgreSQL
- [ ] API REST

## Suporte

Se encontrar problemas ou tiver sugestoes:

1. Abra uma issue no GitHub
2. Consulte o [PRD.md](PRD.md) para detalhes tecnicos
3. Verifique os logs do bot no console

## Licenca

MIT License - Veja o arquivo LICENSE para detalhes.

## Creditos

Desenvolvido para gamificar a participacao em servidores Discord.

---

**Nota**: Este bot deve ser usado de acordo com os Termos de Servico do Discord. O rastreamento de camera e feito apenas para fins de gamificacao e todos os dados sao armazenados localmente.
</file>

</files>
